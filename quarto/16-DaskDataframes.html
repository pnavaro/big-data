<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang=""><head>
  <meta charset="utf-8">
  <meta name="generator" content="quarto-0.2.168">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Python tools for Big Data – daskdataframes</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>

  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script src="site_libs/quarto-nav/quarto-nav.js"></script>
  <script src="site_libs/quarto-nav/headroom.min.js"></script>
  <meta name="quarto:offset" content="./">
  <script src="site_libs/quarto-search/autocomplete.min.js"></script>
  <script src="site_libs/quarto-search/fuse.min.js"></script>
  <script src="site_libs/quarto-search/quarto-search.js"></script>
  <script src="site_libs/quarto-html/quarto.js"></script>
  <script src="site_libs/quarto-html/popper.min.js"></script>
  <script src="site_libs/quarto-html/tippy.umd.min.js"></script>
  <script src="site_libs/quarto-html/clipboard.min.js"></script>
  <script src="site_libs/quarto-html/anchor.min.js"></script>
  <link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
  <link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet">
  <script src="site_libs/bootstrap/bootstrap.min.js"></script>
  <link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
  <link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
<div id="quarto-search-results"></div>
<header id="quarto-header" class="headroom fixed-top">
<nav class="navbar navbar-expand-lg navbar-light ">
    <div class="container-fluid">
  <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Python tools for Big Data</span>
  </a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
      <div class="collapse navbar-collapse" id="navbarCollapse">
        <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./intro.html">Home</a>
  </li>  
</ul>
      </div> <!-- /navcollapse -->
  </div> <!-- /container-fluid -->
</nav>
<nav class="quarto-secondary-nav py-2 d-lg-none d-md-block " data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <div class="container-fluid d-flex justify-content-between">
    <h1 class="quarto-secondary-nav-title mb-0 fs-3 d-inline">(Untitled)</h1>
    <button type="button" class="quarto-btn-toggle btn d-lg-none py-0 px-1 d-inline-block border-0 ">
      <i class="bi bi-chevron-right"></i>
    </button>
  </div>
</nav>
</header>
 <!-- /navbar/sidebar -->
<div class="container-fluid quarto-container d-flex flex-column page-layout-article">
<div class="row flex-fill" id="quarto-content">
  <div id="quarto-sidebar" class="col col-12 col-lg-3 d-lg-flex px-0 pt-0 sidebar collapse sidebar-navigation">
    <nav class="me-lg-auto docked overflow-auto">
    <div class="d-flex px-3 mt-2 flex-shrink-0 align-items-center">
      <div class="sidebar-search">
      <form class="d-flex mb-0">
  <input id="quarto-search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>
      </div>
    </div>
  <div class="sidebar-menu-container"> 
  <ul class="list-unstyled mt-1 px-3">
      <ul class="list-unstyled sidebar-section depth1">
    <li class="">
        <div class="me-auto">
            <a class="sidebar-section-item d-inline-flex text-start w-100 " data-bs-toggle="collapse" data-bs-target="#notebooks-collapse" aria-expanded="true">
              <div class="me-auto sidebar-section-item">Notebooks</div>
            <div><i class="bi bi-chevron-right ms-2"></i></div>
            </a>
        </div>
      <div class="collapse  show" id="notebooks-collapse">
        <ul class="list-unstyled sidebar-item-contents">
          <li class="sidebar-item">
  <a href="./01-GitBasics.html" class="">Git basics</a>
</li>
          <li class="sidebar-item">
  <a href="./02-Installation.html" class="">Installation</a>
</li>
          <li class="sidebar-item">
  <a href="./03-JupyterQuickStart.html" class="">Jupyter</a>
</li>
          <li class="sidebar-item">
  <a href="./04-WordCount.html" class="">Wordcount</a>
</li>
          <li class="sidebar-item">
  <a href="./05-MapReduce.html" class="">Map Reduce</a>
</li>
          <li class="sidebar-item">
  <a href="./06-ParallelComputation.html" class="">Parallel Computation</a>
</li>
          <li class="sidebar-item">
  <a href="./07-AsynchronousProcessing.html" class="">Asynchronous Processing</a>
</li>
          <li class="sidebar-item">
  <a href="./08-DaskDelayed.html" class="">Dask</a>
</li>
          <li class="sidebar-item">
  <a href="./09-DaskBag.html" class="">Dask bag</a>
</li>
          <li class="sidebar-item">
  <a href="./10-PandasSeries.html" class="">Pandas Series</a>
</li>
          <li class="sidebar-item">
  <a href="./11-PandaDataframes.html" class="">Pandas Dataframes</a>
</li>
          <li class="sidebar-item">
  <a href="./12-UnixCommands.html" class="">Basic Commands in the Unix Shell</a>
</li>
          <li class="sidebar-item">
  <a href="./13-Hadoop.html" class="">Hadoop</a>
</li>
          <li class="sidebar-item">
  <a href="./14-FileFormats.html" class="">File Formats</a>
</li>
          <li class="sidebar-item">
  <a href="./15-PySpark.html" class="">PySpark</a>
</li>
          <li class="sidebar-item">
  <a href="./16-DaskDataframes.html" class="active">Dask Dataframes</a>
</li>
          <li class="sidebar-item">
  <a href="./17-SparkDataFrames.html" class="">Spark DataFrames</a>
</li>
          <li class="sidebar-item">
  <a href="./18-NYCTaxiCabTripDask.html" class="">Dask dataframes on HDFS</a>
</li>
          <li class="sidebar-item">
  <a href="./19-NYCTaxiCabTripSpark.html" class="">Spark dataframes on HDFS</a>
</li>
        </ul>
      </div>
    </li>
  </ul>
  </ul>
  </div>
</nav>
  </div>
  <div id="quarto-toc-sidebar" class=" pt-0 col col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-toc order-last"><nav id="TOC" role="doc-toc">
<h2 id="toc-title">On this page</h2>
<ul>
<li><a href="#dask-dataframes" class="nav-link active" data-scroll-target="#dask-dataframes">Dask Dataframes</a>
<ul class="collapse">
<li><a href="#dataframes" class="nav-link" data-scroll-target="#dataframes">DataFrames</a>
<ul class="collapse">
<li><a href="#prep-the-data" class="nav-link" data-scroll-target="#prep-the-data">Prep the Data</a></li>
<li><a href="#load-data-from-csvs-in-dask-dataframes" class="nav-link" data-scroll-target="#load-data-from-csvs-in-dask-dataframes">Load Data from CSVs in Dask Dataframes</a></li>
<li><a href="#what-just-happened" class="nav-link" data-scroll-target="#what-just-happened">What just happened?</a></li>
<li><a href="#why-df-is-ten-times-longer" class="nav-link" data-scroll-target="#why-df-is-ten-times-longer">Why df is ten times longer ?</a></li>
</ul></li>
<li><a href="#computations-with-dask.dataframe" class="nav-link" data-scroll-target="#computations-with-dask.dataframe">Computations with <code>dask.dataframe</code></a></li>
<li><a href="#store-data-in-apache-parquet-format" class="nav-link" data-scroll-target="#store-data-in-apache-parquet-format">Store Data in Apache Parquet Format</a>
<ul class="collapse">
<li><a href="#parquet-advantages" class="nav-link" data-scroll-target="#parquet-advantages">Parquet advantages:</a></li>
<li><a href="#exercise-15.1" class="nav-link" data-scroll-target="#exercise-15.1">Exercise 15.1</a></li>
</ul></li>
<li><a href="#divisions-and-the-index" class="nav-link" data-scroll-target="#divisions-and-the-index">Divisions and the Index</a>
<ul class="collapse">
<li><a href="#exercises-15.2" class="nav-link" data-scroll-target="#exercises-15.2">Exercises 15.2</a></li>
</ul></li>
<li><a href="#sharing-intermediate-results" class="nav-link" data-scroll-target="#sharing-intermediate-results">Sharing Intermediate Results</a></li>
</ul></li>
</ul>
</nav></div>
  <div class="col mx-auto col-sm-12 col-md-9 col-lg-7 col-xl-7 px-lg-4 pe-xxl-4 ps-xxl-0">
<main>

<section id="dask-dataframes" class="level1">
<h1>Dask Dataframes</h1>
<p><em><a href="http://dask.pydata.org">Dask</a> is a flexible parallel computing library for analytic computing</em> written in Python. Dask is similar to Spark, by lazily constructing directed acyclic graph (DAG) of tasks and splitting large datasets into small portions called partitions. See the below image from <a href="http://dask.pydata.org">Dask’s web page</a> for illustration.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/collections-schedulers.png" class="img-fluid figure-img"></p>
<p></p><figcaption aria-hidden="true" class="figure-caption">http://dask.pydata.org/en/latest/_images/collections-schedulers.png</figcaption><p></p>
</figure>
</div>
<p>It has three main interfaces:</p>
<ul>
<li><a href="http://dask.pydata.org/en/latest/array.html">Array</a>, which works like <a href="http://www.numpy.org/">NumPy</a> arrays;</li>
<li><a href="http://dask.pydata.org/en/latest/bag.html">Bag</a>, which is similar to RDD interface in Spark;</li>
<li><a href="http://dask.pydata.org/en/latest/dataframe.html">DataFrame</a>, which works like <a href="https://pandas.pydata.org/">Pandas</a> DataFrame.</li>
</ul>
<p>While it can work on a <a href="http://dask.pydata.org/en/latest/distributed.html">distributed cluster</a>, Dask works also very well on a single cpu machine.</p>
<section id="dataframes" class="level2">
<h2 class="anchored" data-anchor-id="dataframes">DataFrames</h2>
<p>Dask dataframes look and feel (mostly) like Pandas dataframes but they run on the same infrastructure that powers dask.delayed.</p>
<p>The <code>dask.dataframe</code> module implements a blocked parallel <code>DataFrame</code> object that mimics a large subset of the Pandas <code>DataFrame</code>. One dask <code>DataFrame</code> is comprised of many in-memory pandas <code>DataFrames</code> separated along the index. One operation on a dask <code>DataFrame</code> triggers many pandas operations on the constituent pandas <code>DataFrame</code>s in a way that is mindful of potential parallelism and memory constraints.</p>
<p><strong>Related Documentation</strong></p>
<ul>
<li><a href="http://dask.pydata.org/en/latest/dataframe.html">Dask DataFrame documentation</a></li>
<li><a href="http://pandas.pydata.org/">Pandas documentation</a></li>
</ul>
<p>In this notebook, we will extracts some historical flight data for flights out of NYC between 1990 and 2000. The data is taken from <a href="http://stat-computing.org/dataexpo/2009/the-data.html">here</a>. This should only take a few seconds to run.</p>
<p>We will use <code>dask.dataframe</code> construct our computations for us. The <code>dask.dataframe.read_csv</code> function can take a globstring like <code>"data/nycflights/*.csv"</code> and build parallel computations on all of our data at once.</p>
<p><strong>Variable descriptions</strong></p>
<p>Name Description</p>
<ol type="1">
<li><code>Year</code> 1987-2008</li>
<li><code>Month</code> 1-12</li>
<li><code>DayofMonth</code> 1-31</li>
<li><code>DayOfWee</code> 1 (Monday) - 7 (Sunday)</li>
<li><code>DepTime</code> actual departure time (local, hhmm)</li>
<li><code>CRSDepTime</code> scheduled departure time (local, hhmm)</li>
<li><code>ArrTime</code> actual arrival time (local, hhmm)</li>
<li><code>CRSArrTime</code> scheduled arrival time (local, hhmm)</li>
<li><code>UniqueCarrier</code> unique carrier code</li>
<li><code>FlightNum</code> flight number</li>
<li><code>TailNu</code> plane tail number</li>
<li><code>ActualElapsedTime</code> in minutes</li>
<li><code>CRSElapsedTime</code> in minutes</li>
<li><code>AirTime</code> in minutes</li>
<li><code>ArrDelay</code> arrival delay, in minutes</li>
<li><code>DepDelay</code> departure delay, in minutes</li>
<li><code>Origin</code> origin IATA airport code</li>
<li><code>Dest</code> destination IATA airport code</li>
<li><code>Distance</code> in miles</li>
<li><code>TaxiIn</code> taxi in time, in minutes</li>
<li><code>TaxiOut</code> taxi out time in minutes</li>
<li><code>Cancelled</code> was the flight cancelled?</li>
<li><code>CancellationCode</code> reason for cancellation (A = carrier, B = weather, C = NAS, D = security)</li>
<li><code>Diverted</code> 1 = yes, 0 = no</li>
<li><code>CarrierDelay</code> in minutes</li>
<li><code>WeatherDelay</code> in minutes</li>
<li><code>NASDelay</code> in minutes</li>
<li><code>SecurityDelay</code> in minutes</li>
<li><code>LateAircraftDelay</code> in minutes</li>
</ol>
<section id="prep-the-data" class="level3">
<h3 class="anchored" data-anchor-id="prep-the-data">Prep the Data</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>pd.set_option(<span class="st">"max.rows"</span>, <span class="dv">10</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>os.getcwd()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os  <span class="co"># library to get directory and file paths</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tarfile <span class="co"># this module makes possible to read and write tar archives</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> extract_flight():</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    here <span class="op">=</span> os.getcwd()</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    flightdir <span class="op">=</span> os.path.join(here,<span class="st">'data'</span>, <span class="st">'nycflights'</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> os.path.exists(flightdir):</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>       <span class="bu">print</span>(<span class="st">"Extracting flight data"</span>)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>       tar_path <span class="op">=</span> os.path.join(<span class="st">'data'</span>, <span class="st">'nycflights.tar.gz'</span>)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>       <span class="cf">with</span> tarfile.<span class="bu">open</span>(tar_path, mode<span class="op">=</span><span class="st">'r:gz'</span>) <span class="im">as</span> flights:</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>          flights.extractall(<span class="st">'data/'</span>)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>extract_flight() <span class="co"># this function call will extract 10 csv files in data/nycflights</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="load-data-from-csvs-in-dask-dataframes" class="level3">
<h3 class="anchored" data-anchor-id="load-data-from-csvs-in-dask-dataframes">Load Data from CSVs in Dask Dataframes</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>here <span class="op">=</span> os.getcwd()</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>filenames <span class="op">=</span> os.path.join(here, <span class="st">'data'</span>, <span class="st">'nycflights'</span>, <span class="st">'*.csv'</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>filenames</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> dask</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> dask.dataframe <span class="im">as</span> dd</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> dd.read_csv(filenames,</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>                 parse_dates<span class="op">=</span>{<span class="st">'Date'</span>: [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>]})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s take a look to the dataframe</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">### Get the first 5 rows</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>df.head(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> traceback <span class="co"># we use traceback because we expect an error.</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    df.tail(<span class="dv">5</span>) <span class="co"># Get the last 5 rows</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">Exception</span>:</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    traceback.print_exc()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="what-just-happened" class="level3">
<h3 class="anchored" data-anchor-id="what-just-happened">What just happened?</h3>
<p>Unlike <code>pandas.read_csv</code> which reads in the entire file before inferring datatypes, <code>dask.dataframe.read_csv</code> only reads in a sample from the beginning of the file (or first file if using a glob). These inferred datatypes are then enforced when reading all partitions.</p>
<p>In this case, the datatypes inferred in the sample are incorrect. The first <code>n</code> rows have no value for <code>CRSElapsedTime</code> (which pandas infers as a <code>float</code>), and later on turn out to be strings (<code>object</code> dtype). When this happens you have a few options:</p>
<ul>
<li>Specify dtypes directly using the <code>dtype</code> keyword. This is the recommended solution, as it’s the least error prone (better to be explicit than implicit) and also the most performant.</li>
<li>Increase the size of the <code>sample</code> keyword (in bytes)</li>
<li>Use <code>assume_missing</code> to make <code>dask</code> assume that columns inferred to be <code>int</code> (which don’t allow missing values) are actually floats (which do allow missing values). In our particular case this doesn’t apply.</li>
</ul>
<p>In our case we’ll use the first option and directly specify the <code>dtypes</code> of the offending columns.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>df.dtypes</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> dd.read_csv(filenames,</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>                 parse_dates<span class="op">=</span>{<span class="st">'Date'</span>: [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>]},</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                 dtype<span class="op">=</span>{<span class="st">'TailNum'</span>: <span class="bu">object</span>,</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>                        <span class="st">'CRSElapsedTime'</span>: <span class="bu">float</span>,</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>                        <span class="st">'Cancelled'</span>: <span class="bu">bool</span>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>df.tail(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s take a look at one more example to fix ideas.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="why-df-is-ten-times-longer" class="level3">
<h3 class="anchored" data-anchor-id="why-df-is-ten-times-longer">Why df is ten times longer ?</h3>
<ul>
<li>Dask investigated the input path and found that there are ten matching files.</li>
<li>A set of jobs was intelligently created for each chunk - one per original CSV file in this case.</li>
<li>Each file was loaded into a pandas dataframe, had <code>len()</code> applied to it.</li>
<li>The subtotals were combined to give you the final grant total.</li>
</ul>
</section>
</section>
<section id="computations-with-dask.dataframe" class="level2">
<h2 class="anchored" data-anchor-id="computations-with-dask.dataframe">Computations with <code>dask.dataframe</code></h2>
<p>We compute the maximum of the <code>DepDelay</code> column. With <code>dask.delayed</code> we could create this computation as follows:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>maxes <span class="op">=</span> []</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> fn <span class="kw">in</span> filenames:</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> dask.delayed(pd.read_csv)(fn)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    maxes.append(df.DepDelay.<span class="bu">max</span>())</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>final_max <span class="op">=</span> dask.delayed(<span class="bu">max</span>)(maxes)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>final_max.compute()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now we just use the normal Pandas syntax as follows:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time df.DepDelay.<span class="bu">max</span>().compute()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This writes the delayed computation for us and then runs it. Recall that the delayed computation is a dask graph made of up of key-value pairs.</p>
<p>Some things to note:</p>
<ol type="1">
<li>As with <code>dask.delayed</code>, we need to call <code>.compute()</code> when we’re done. Up until this point everything is lazy.</li>
<li>Dask will delete intermediate results (like the full pandas dataframe for each file) as soon as possible.
<ul>
<li>This lets us handle datasets that are larger than memory</li>
<li>This means that repeated computations will have to load all of the data in each time (run the code above again, is it faster or slower than you would expect?)</li>
</ul></li>
</ol>
<p>As with <code>Delayed</code> objects, you can view the underlying task graph using the <code>.visualize</code> method:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>df.DepDelay.<span class="bu">max</span>().visualize()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>If you are already familiar with the Pandas API then know how to use <code>dask.dataframe</code>. There are a couple of small changes.</p>
<p>As noted above, computations on dask <code>DataFrame</code> objects don’t perform work, instead they build up a dask graph. We can evaluate this dask graph at any time using the <code>.compute()</code> method.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> df.DepDelay.mean()  <span class="co"># create the tasks graph</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time result.compute()           <span class="co"># perform actual computation</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="store-data-in-apache-parquet-format" class="level2">
<h2 class="anchored" data-anchor-id="store-data-in-apache-parquet-format">Store Data in Apache Parquet Format</h2>
<p>Dask encourage dataframe users to store and load data using Parquet instead of csv. <a href="http://parquet.apache.org/">Apache Parquet</a> is a columnar binary format that is easy to split into multiple files (easier for parallel loading) and is generally much simpler to deal with than HDF5 (from the Dask library’s perspective). It is also a common format used by other big data systems like <a href="http://spark.apache.org/">Apache Spark</a> and <a href="http://impala.apache.org/">Apache Impala</a> and so is useful to interchange with other systems.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>df.drop(<span class="st">"TailNum"</span>, axis<span class="op">=</span><span class="dv">1</span>).to_parquet(<span class="st">"nycflights/"</span>)  <span class="co"># save csv files using parquet format</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It is possible to specify dtypes and compression when converting. This can definitely help give you significantly greater speedups, but just using the default settings will still be a large improvement.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>df.size.compute()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb19"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> dask.dataframe <span class="im">as</span> dd</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> dd.read_parquet(<span class="st">"nycflights/"</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> df.DepDelay.mean() </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time result.compute()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The computation is much faster because pulling out the DepDelay column is easy for Parquet.</p>
<section id="parquet-advantages" class="level3">
<h3 class="anchored" data-anchor-id="parquet-advantages">Parquet advantages:</h3>
<ul>
<li>Binary representation of data, allowing for speedy conversion of bytes-on-disk to bytes-in-memory</li>
<li>Columnar storage, meaning that you can load in as few columns as you need without loading the entire dataset</li>
<li>Row-chunked storage so that you can pull out data from a particular range without touching the others</li>
<li>Per-chunk statistics so that you can find subsets quickly</li>
<li>Compression</li>
</ul>
</section>
<section id="exercise-15.1" class="level3">
<h3 class="anchored" data-anchor-id="exercise-15.1">Exercise 15.1</h3>
<p>If you don’t remember how to use pandas. Please read <a href="http://pandas.pydata.org/">pandas documentation</a>.</p>
<ul>
<li>Use the <code>head()</code> method to get the first ten rows</li>
<li>How many rows are in our dataset?</li>
<li>Use selections <code>df[...]</code> to find how many positive (late) and negative (early) departure times there are</li>
<li>In total, how many non-cancelled flights were taken? (To invert a boolean pandas Series s, use ~s).</li>
</ul>
</section>
</section>
<section id="divisions-and-the-index" class="level2">
<h2 class="anchored" data-anchor-id="divisions-and-the-index">Divisions and the Index</h2>
<p>The Pandas index associates a value to each record/row of your data. Operations that align with the index, like <code>loc</code> can be a bit faster as a result.</p>
<p>In <code>dask.dataframe</code> this index becomes even more important. Recall that one dask <code>DataFrame</code> consists of several Pandas <code>DataFrame</code>s. These dataframes are separated along the index by value. For example, when working with time series we may partition our large dataset by month.</p>
<p>Recall that these many partitions of our data may not all live in memory at the same time, instead they might live on disk; we simply have tasks that can materialize these pandas <code>DataFrames</code> on demand.</p>
<p>Partitioning your data can greatly improve efficiency. Operations like <code>loc</code>, <code>groupby</code>, and <code>merge/join</code> along the index are <em>much more efficient</em> than operations along other columns. You can see how your dataset is partitioned with the <code>.divisions</code> attribute. Note that data that comes out of simple data sources like CSV files aren’t intelligently indexed by default. In these cases the values for <code>.divisions</code> will be <code>None.</code></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> dd.read_csv(filenames,</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>                 dtype<span class="op">=</span>{<span class="st">'TailNum'</span>: <span class="bu">str</span>,</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>                        <span class="st">'CRSElapsedTime'</span>: <span class="bu">float</span>,</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>                        <span class="st">'Cancelled'</span>: <span class="bu">bool</span>})</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>df.divisions</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>However if we set the index to some new column then dask will divide our data roughly evenly along that column and create new divisions for us. Warning, <code>set_index</code> triggers immediate computation.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>df2 <span class="op">=</span> df.set_index(<span class="st">'Year'</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>df2.divisions</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We see here the minimum and maximum values (1990 and 1999) as well as the intermediate values that separate our data well. This dataset has ten partitions, as the final value is assumed to be the inclusive right-side for the last bin.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>df2.npartitions</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>df2.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>One of the benefits of this is that operations like <code>loc</code> only need to load the relevant partitions</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>df2.loc[<span class="dv">1991</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>df2.loc[<span class="dv">1991</span>].compute()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="exercises-15.2" class="level3">
<h3 class="anchored" data-anchor-id="exercises-15.2">Exercises 15.2</h3>
<p>In this section we do a few <code>dask.dataframe</code> computations. If you are comfortable with Pandas then these should be familiar. You will have to think about when to call <code>compute</code>.</p>
<ul>
<li>In total, how many non-cancelled flights were taken from each airport?</li>
</ul>
<p><em>Hint</em>: use <a href="https://pandas.pydata.org/pandas-docs/stable/groupby.html"><code>df.groupby</code></a>. <code>df.groupby(df.A).B.func()</code>.</p>
<ul>
<li>What was the average departure delay from each airport?</li>
</ul>
<p>Note, this is the same computation you did in the previous notebook (is this approach faster or slower?)</p>
<ul>
<li>What day of the week has the worst average departure delay?</li>
</ul>
</section>
</section>
<section id="sharing-intermediate-results" class="level2">
<h2 class="anchored" data-anchor-id="sharing-intermediate-results">Sharing Intermediate Results</h2>
<p>When computing all of the above, we sometimes did the same operation more than once. For most operations, <code>dask.dataframe</code> hashes the arguments, allowing duplicate computations to be shared, and only computed once.</p>
<p>For example, lets compute the mean and standard deviation for departure delay of all non-cancelled flights:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>non_cancelled <span class="op">=</span> df[<span class="op">~</span>df.Cancelled]</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>mean_delay <span class="op">=</span> non_cancelled.DepDelay.mean()</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>std_delay <span class="op">=</span> non_cancelled.DepDelay.std()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="using-two-calls-to-.compute" class="level4">
<h4 class="anchored" data-anchor-id="using-two-calls-to-.compute">Using two calls to <code>.compute</code>:</h4>
<div class="sourceCode" id="cb29"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>mean_delay_res <span class="op">=</span> mean_delay.compute()</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>std_delay_res <span class="op">=</span> std_delay.compute()</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>mean_delay_res, std_delay_res</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="using-one-call-to-dask.compute" class="level4">
<h4 class="anchored" data-anchor-id="using-one-call-to-dask.compute">Using one call to <code>dask.compute</code>:</h4>
<div class="sourceCode" id="cb30"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>mean_delay_res, std_delay_res <span class="op">=</span> dask.compute(mean_delay, std_delay)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>mean_delay_res, std_delay_res</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Using <code>dask.compute</code> takes roughly 1/2 the time. This is because the task graphs for both results are merged when calling <code>dask.compute</code>, allowing shared operations to only be done once instead of twice. In particular, using <code>dask.compute</code> only does the following once:</p>
<ul>
<li>the calls to <code>read_csv</code></li>
<li>the filter (<code>df[~df.Cancelled]</code>)</li>
<li>some of the necessary reductions (<code>sum</code>, <code>count</code>)</li>
</ul>
<p>To see what the merged task graphs between multiple results look like (and what’s shared), you can use the <code>dask.visualize</code> function (we might want to use <code>filename='graph.pdf'</code> to zoom in on the graph better):</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python cell-code code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>dask.visualize(mean_delay, std_delay)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>

</section>
</section>
</section>
<script type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    setTimeout(function() {
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    window.tippy(el, {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    }); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      const id = new URL(ref.getAttribute('href')).hash.replace(/^#/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</main>
<div class="page-navigation page-navigation-docked">
  <div class="nav-page nav-page-previous">
  </div>
  <div class="nav-page nav-page-next">
  </div>
</div>
</div> <!-- /main column -->
</div> <!-- /row -->
</div> <!-- /container fluid -->


</body></html>